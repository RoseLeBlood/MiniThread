.TH "basic_autolock< LOCK >" 3 "Tue Sep 15 2020" "Version 1.6x" "Mini Thread" \" -*- nroff -*-
.ad l
.nh
.SH NAME
basic_autolock< LOCK >
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <mn_autolock\&.hpp>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBbasic_autolock\fP (LOCK &m)"
.br
.ti -1c
.RI "\fB~basic_autolock\fP ()"
.br
.ti -1c
.RI "\fBbasic_autolock\fP (const \fBbasic_autolock\fP &)=delete"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "LOCK & \fBm_ref_lock\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<class LOCK = basic_mutex>
.br
class basic_autolock< LOCK >"
This file is part of the Mini Thread Library (https://github.com/RoseLeBlood/MiniThread )\&. Copyright (c) 2018 Amber-Sophia Schroeck
.PP
The Mini Thread Library is free software; you can redistribute it and/or modify 
.br
 it under the terms of the GNU Lesser General Public License as published by 
.br
 the Free Software Foundation, version 3, or (at your option) any later version\&.
.PP
The Mini Thread Library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE\&. See the GNU General Public License for more details\&.
.PP
You should have received a copy of the GNU Lesser General Public License along with the Mini Thread Library; if not, see https://www.gnu.org/licenses/\&. 
.br
 Synchronization helper class that leverages the C++ language to help prevent deadlocks\&. This is a C++11 feature that allows LockObject Locking and Unlocking to behave following an RAII style\&. The constructor of this helper object locks the LockObject\&. The destructor unlocks the LockObject\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<class LOCK  = basic_mutex> \fBbasic_autolock\fP< LOCK >::\fBbasic_autolock\fP (LOCK & m)\fC [inline]\fP"
Create a \fBbasic_autolock\fP with a specific LockType\&.
.PP
\fBPostcondition\fP
.RS 4
The LockObject will be locked\&. 
.RE
.PP

.SS "template<class LOCK  = basic_mutex> \fBbasic_autolock\fP< LOCK >::~\fBbasic_autolock\fP ()\fC [inline]\fP"
Destroy a \fBbasic_autolock\fP\&.
.PP
\fBPostcondition\fP
.RS 4
The LockObject will be unlocked\&. 
.RE
.PP

.SS "template<class LOCK  = basic_mutex> \fBbasic_autolock\fP< LOCK >::\fBbasic_autolock\fP (const \fBbasic_autolock\fP< LOCK > &)\fC [delete]\fP"
We do not want a copy constructor\&. 
.SH "Member Data Documentation"
.PP 
.SS "template<class LOCK  = basic_mutex> LOCK& \fBbasic_autolock\fP< LOCK >::m_ref_lock\fC [private]\fP"
Reference to the LockObject we locked, so it can be unlocked in the destructor\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for Mini Thread from the source code\&.
